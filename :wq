#ifndef MY_FORWARD_LIST_H
#define MY_FORWARD_LIST_H

#include <type_traits>
#include <initializer_list>
#include <memory>
#include "iterator.h"

namespace learnSTL{
    template<typename NodePtr>
    struct __forward_head_node{
        NodePtr __next;

        __forward_head_node() : __next(nullptr) {}
    };

    template<typename T, typename VoidPtr> struct __forward_list_node;

    template<typename T, typename VoidPtr>
    struct __head_node_of{
        using __NodePtr = typename std::pointer_traits<VoidPtr>::template rebind<__forward_list_node<T, VoidPtr> >;
        using type = __forward_head_node<__NodePtr>;
    };


    template<typename T, typename VoidPtr>
    struct __forward_list_node : __head_node_of<T, VoidPtr>::type{
        using value_type = T;
        T __data;
    };

    template<typename T, typename Allocator> class forward_list;
    template<typename ConstNodePtr> class __forward_list_const_iterator;

    template<typename NodePtr>
    class __forward_list_iterator{
    public:
        using iterator_category = forward_iterator_tag;
        using value_type        = typename std::pointer_traits<NodePtr>::element_type::value_type;
        using difference_type   = typename std::pointer_traits<NodePtr>::difference_type;
        using reference         = value_type&;
        using pointer           = typename std::pointer_traits<NodePtr>:: template rebind<value_type>;
        
        __forward_list_iterator() : __ptr(nullptr) {}

        reference operator*() const { return __ptr->__data; }
        pointer operator->() const { return std::pointer_traits<pointer>::pointer_to(__ptr->__data); }

        __forward_list_iterator& operator++(){
            __ptr = __ptr->__next;
            return *this;
        }
        __forward_list_iterator& operator++(int){
            __forward_list_iterator temp(*this);
            __ptr = __ptr->__next;
            return temp;
        }
        friend bool operator==(const __forward_list_iterator& iter1, const __forward_list_iterator& iter2){
            return iter1.__ptr == iter2.__ptr;
        }
        friend bool operator!=(const __forward_list_iterator& iter1, const __forward_list_iterator& iter2){
            return iter1.__ptr != iter2.__ptr;
        }

    private:
        NodePtr __ptr;

        explicit __forward_list_iterator(NodePtr p) : __ptr(p) {}
        template<typename ,typename> friend class forward_list;      // only for forward_list
        template<typename> friend class __forward_list_const_iterator;
    };

    template<typename ConstNodePtr>
    class __forward_list_const_iterator{
        using __node_type = typename std::remove_const<typename std::pointer_traits<ConstNodePtr>::element_type>::type;
        using __NodePtr = typename std::pointer_traits<ConstNodePtr>:: template rebind<__node_type>;
    public:
        using iterator_category = forward_iterator_tag;
        using value_type        = typename __node_type::value_type;
        using difference_type   = typename std::pointer_traits<ConstNodePtr>::difference_type;
        using reference         = const value_type&;
        using pointer           = typename std::pointer_traits<ConstNodePtr>:: template rebind<const value_type>;
        
        __forward_list_const_iterator() : __ptr(nullptr) {}
        __forward_list_const_iterator(__forward_list_iterator<__NodePtr> iter) : __ptr(iter.__ptr) {}

        reference operator*() const { return __ptr->__data; }
        pointer operator->() const { return std::pointer_traits<pointer>::pointer_to(__ptr->__data); }
        
        __forward_list_const_iterator& operator++(){
            __ptr = __ptr->__next;
            return *this;
        }
        __forward_list_const_iterator& operator++(int){
            __forward_list_const_iterator temp(*this);
            __ptr = __ptr->__next;
            return temp;
        }

        friend bool operator==(const __forward_list_const_iterator& iter1, const __forward_list_const_iterator iter2){
            return iter1.__ptr == iter2.__ptr;
        }
        friend bool operator==(const __forward_list_const_iterator& iter1, const __forward_list_const_iterator iter2){
            return iter1.__ptr != iter2.__ptr;
        }
        
    private:
        ConstNodePtr __ptr;

        explicit __forward_list_const_iterator(ConstNodePtr p) : __ptr(p) {}
        template<typename, typename> friend class forward_list; 
    };

    template<typename T, typename Allocator=std::allocator<T> >
    class __forward_list_base{
    protected:
        using value_type = T;
        using allocator_type = Allocator;

        using void_pointer     = typename std::allocator_traits<allocator_type>::void_pointer;
        using __node_type      = __forward_list_node<T, void_pointer>;
        using __head_node_type = typename __head_node_of<T, void_pointer>::type;
        using __node_alloc     = typename std::allocator_traits<allocator_type>::template rebind_alloc<__node_type>;
        using __node_traits    = std::allocator_traits<__node_alloc>;
        using __node_pointer   = typename __node_traits::pointer;

        using iterator       = __forward_list_iterator<__node_pointer>;
        using const_iterator = __forward_list_const_iterator<__node_pointer>;

        __head_node_type __head;
        __node_alloc __alloc;

        // constructor
        __forward_list_base() : __head(), __alloc() {}
        __forward_list_base(const allocator_type& a) : __head(), __alloc(a) {}
    
        void clear(){
            for(__node_pointer p = __head->__next; p != nullptr; p = p->__next){
                __node_traits::destroy(__alloc, std::addressof(p->__data));
                __node_traits::deallocate(__alloc, p, 1);
            }
            __head->__next = nullptr;
        }

        ~__forward_list_base(){
            clear();
        }

        void __copy_assign_alloc(const __forward_list_base& f){
            __copy_assign_alloc(f, std::integral_constant<bool, __node_traits::propagate_on_container_copy_assignment::value>());
        }

        void __move_assign_alloc(__forward_list_base& rf){
            __move_assign_alloc(rf, std::integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
        }

        void swap(__forward_list_base& f2){
            __swap_alloc(__alloc, f2.__alloc, std::integral_constant<bool, __node_traits::propagate_on_container_swap::value>());
            swap(__head->__next, f2.__head->__next);
        }
        
    private:
        void __copy_assign_alloc(const __forward_list_base& f, std::true_type){
            if(__alloc != f.__alloc)
                clear();
            __alloc = f.__alloc;
        }
        void __copy_assign_alloc(const __forward_list_base&, std::false_type) {}

        void __move_assign_alloc(__forward_list_base& rf, std::true_type){
            // clear is left to the forward_list
            __alloc = move(rf.__alloc);
        }
        void __move_assign_alloc(__forward_list_base&, std::false_type) {}

        void __swap_alloc(__node_alloc& a1, __node_alloc& a2, std::true_type){
            swap(a1, a2);
        }
        void __swap_alloc(__node_alloc&, __node_alloc, std::false_type) {}
    };

    // ------ forward_list -----------
    template<typename T, typename Allocator = std::allocator<T> >
    class forward_list : private __forward_list_base<T, Allocator>
    {
        using base = __forward_list_base<T, Allocator>;
        using __node_type = typename base::__node_type;
        using __node_pointer = typename base::__node_pointer;
        using __node_alloc = typename base::__node_alloc;
        using __node_traits = typename base::__node_traits;
    public:
        using value_type       = T;
        using allocator_type   = Allocator;
        using size_type        = typename std::allocator_traits<allocator_type>::size_type;
        using difference_type  = typename std::allocator_traits<allocator_type>::difference_type;
        using reference        = value_type&;
        using const_reference  = const value_type&;
        using pointer          = typename std::allocator_traits<allocator_type>::pointer;
        using const_pointer    = typename std::allocator_traits<allocator_type>::const_pointer;
        
        using iterator = typename base::iterator;
        using const_iterator = typename base::const_iterator;

        // iterator
        iterator before_begin() { return iterator(this->__head); }
        const_iterator before_begin() const { return const_iterator(this->__head); }
        const_iterator cbefore_begin() const { return const_iterator(this->__head); }

        iterator begin() { return iterator(this->__head->__next); }
        const_iterator begin() const { return const_iterator(this->__head->__next); }
        const_iterator cbegin() const { return const_iterator(this->__head->__next); }

        iterator end() { return iterator(nullptr); }
        const_iterator end() const { return const_iterator(nullptr); }
        const_iterator cend() const { return const_iterator(nullptr); }

        allocator_type get_allocator() const { return this->__alloc; }

        // constructor
        forward_list() {}     // default
        explicit forward_list(const allocator_type& a) : base(a) {}

        forward_list(size_type n){
            insert_after(before_begin(), n, value_type());
        }

        forward_list(size_type n, const_reference val){
            insert_after(before_begin(), n, val);
        }

        template<typename InputIter>
            forward_list(InputIter first, InputIter last){
               insert_after(before_begin(), first, last); 
            }



        // insert_after
        iterator insert_after(const_iterator pos, size_type n, const_reference val){
            __node_pointer p = pos.__ptr;
            if(n > 0){
                std::unique_ptr<__node_type> node_up(__node_traits::allocate(this->__alloc, 1));
                __node_traits::construct(this->__alloc, std::addressof(node_up->__data), val);
                __node_pointer first = node_up.release();
                __node_pointer last = first;
                for(--n; n > 0; --n, last = last->__next){
                    node_up.reset(__node_traits::allocate(this->__alloc, 1));
                    __node_traits::construct(this->__alloc, std::addressof(node_up->__data), val);
                    last->__next = node_up.release();
                }
                last->__next = p->__next;
                p->__next = first;
                p = last;
            }
            return iterator(p);
        }

        template<typename InputIter>
            iterator insert_after(const_iterator pos, InputIter first, InputIter last){
                __node_pointer p = pos.__ptr;
                if(first != last){
                    std::unique_ptr<__node_type> node_up(__node_traits::allocate(this->__alloc, 1));
                    __node_traits::construct(this->__alloc, std::addressof(node_up->__data), *first);
                    __node_pointer first_node_p = node_up.release();
                    __node_pointer last_node_p = first_node_p;
                    for(++first; first != last; ++first, last_node_p = last_node_p->__next){
                        node_up.reset(__node_traits::allocate(this->__alloc, 1));
                        __node_traits::construct(this->__alloc, std::addressof(node_up->__data), *first);
                        last_node_p->__next = node_up.release();
                    }
                    last_node_p->__next = p->__next;
                    p->__next = first_node_p;
                    p = last_node_p;
                }
                return iterator(p);
            }
    };
}
#endif
